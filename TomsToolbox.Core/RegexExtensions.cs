namespace TomsToolbox.Core
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;
    using System.Linq;
    using System.Text.RegularExpressions;

    using JetBrains.Annotations;

    /// <summary>
    /// Extension methods for <see cref="Regex"/>.
    /// </summary>
    public static class RegexExtensions
    {
        /// <summary>
        /// Splits an input string into an array of substrings at the positions defined by the <paramref name="regex"/> regular expression.
        /// </summary>
        /// <typeparam name="T">The type of the returned items.</typeparam>
        /// <param name="regex">The regular expression used to split the string.</param>
        /// <param name="input">The string to split.</param>
        /// <param name="itemGenerator">The item generator used to generate the individual fragments to return. It will get the items string value plus a boolean indicator whether the item was a match or the text in between the matches.</param>
        /// <returns>The items generated by the <paramref name="itemGenerator"/>, an alternating list of non-matched and matched fragments.</returns>
        /// <remarks>
        /// Similar to <see cref="Regex.Split(string)"/>, but returns and alternating list of both matches and non-matches.
        /// It's up to the item generator how matched and non-matched items are handled.
        /// Concatenating all unmodified fragment values will always return the original string.
        /// </remarks>
        [NotNull, ItemCanBeNull]
        public static IEnumerable<T> Split<T>([NotNull] this Regex regex, [NotNull] string input, [NotNull] Func<string, bool, T> itemGenerator)
        {
            Contract.Requires(input != null);
            Contract.Requires(regex != null);
            Contract.Requires(itemGenerator != null);
            Contract.Ensures(Contract.Result<IEnumerable<T>>() != null);

            // ReSharper disable once AssignNullToNotNullAttribute
            var textParts = regex.Matches(input).Cast<Match>().ToArray();

            Match previousTextPart = null;

            foreach (var textPart in textParts)
            {
                if (textPart == null)
                    continue;

                var startIndex = previousTextPart?.Index + previousTextPart?.Length ?? 0;

                yield return itemGenerator(input.Substring(startIndex, textPart.Index - startIndex), false);
                yield return itemGenerator(textPart.Value, true);

                previousTextPart = textPart;
            }

            yield return itemGenerator(input.Substring(previousTextPart?.Index + previousTextPart?.Length ?? 0), false);
        }
    }
}
